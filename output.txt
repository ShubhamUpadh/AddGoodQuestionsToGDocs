
02ShiftAll0ToEndGOOD.ipynb
def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        slow = 0
        while slow < len(nums):
            if nums[slow] == 0:
                break
            slow += 1
        else:
            print("here")
            return
        fast = slow
        while fast < len(nums):
            if nums[fast] == 0:
                fast += 1
                continue
            nums[fast], nums[slow] = nums[slow], nums[fast]
            slow = slow + 1
            fast = fast + 1

04RotateLeftByKStepsGood.ipynb
def reverse(arr,lower,upper):
    while lower < upper:
        arr[lower], arr[upper] = arr[upper], arr[lower]
        lower += 1
        upper += 1
def leftKSteps(arr,k):
    n = len(arr)
    reverse(arr,0,n-1)
    reverse(arr,0,n-k-1)
    reverse(arr,n-k,n-1)

06FindELementThatOccursOnceInSortedArrayGood.ipynb
def numberOccursOnce(arr):
    for i in range(len(arr)):
        if i % 2 == 0:
            if arr[i] != arr[i+1]:
                return arr[i]
def numberOccursOnce(arr):
    lower, upper = 0, len(arr) - 1
    while lower <= upper:
        mid = (lower+upper)//2
        if (mid % 2 == 0 and mid < len(arr)-1 and arr[mid] == arr[mid+1]) or (mid % 2 != 0 and mid > 0 and arr[mid] == arr[mid-1]):
            lower = mid + 1
        elif (mid % 2 == 0 and mid > 0 and arr[mid] == arr[mid-1]) or (mid % 2 != 0 and mid < len(arr) - 1 and arr[mid] == arr[mid+1]):
            upper  = mid - 1
        else:
            return arr[mid]

09AlternateNumbersGood.ipynb
# an array contains equal number of negative and positive integers
# return an array that has alternate pos, neg numbers
# 0 is positive
# start from positive

def alternateNumbers(arr):
    n = len(arr)
    res = [0]*n
    posId, negId = 0, 1
    for i in range(n):
        if arr[i] < 0:
            res[negId] = arr[i]
            negId += 2
        else:
            res[posId] = arr[i]
            posId += 2
    return res
'''
Given an unsorted array Arr of N positive and negative numbers. Your task is to create an array of alternate positive and negative numbers without changing the relative order of positive and negative numbers.
Note: Array should start with a positive number and 0 (zero) should be considered a positive element.
It might be possible that number of negative and positve integers are not equal
'''
def rearrange(self,arr, n):
    # code here
    posNos, negNos = [], []
    for i in arr:
        if i < 0:
            negNos.append(i)
        else:
            posNos.append(i)
    p1, p2=0, 0
    #print(posNos, negNos)
    for i in range(n):
        if p1 == len(posNos) or p2 == len(negNos):
            break
        if i % 2 == 0:
            arr[i] = posNos[p1]
            p1 += 1
        elif i % 2:
            arr[i] = negNos[p2]
            p2 += 1
        #print(arr[:i+1])
    if p1 < len(posNos):
        #print("Here")
        for j in range(i,len(arr)):
            arr[j] = posNos[p1]
            #print(arr[:j+1])
            p1 += 1
    else:
        for j in range(i,len(arr)):
            arr[j] = negNos[p2]
            #print(arr[:j+1])
            p2 += 1

10NextArrayPermutationGood.ipynb
# https://leetcode.com/problems/next-permutation/description/
def nextPermutation(self, nums: List[int]) -> None:
    """
    Do not return anything, modify nums in-place instead.
    """
    flag = False
    for i in range(len(nums)-1,0,-1):
        if nums[i] > nums[i-1]:
            flag = True
            break
    if not flag:    # the array is in descending order
        lower, upper = 0, len(nums) - 1
        while lower < upper:
            nums[lower], nums[upper] = nums[upper], nums[lower]
            lower += 1
            upper -= 1
        return

    pivot = i - 1       #found the pivot element
    jMaxId, minDiff = -1, float("inf")
    for i in range(pivot+1,len(nums)):  #find the just greater element than pivot
        if nums[i] > nums[pivot] and minDiff > nums[i] - nums[pivot]:
            jMaxId = i 
    nums[pivot], nums[jMaxId] = nums[jMaxId], nums[pivot]
    #reverse the array after pivot
    lower, upper = pivot + 1, len(nums) - 1
    while lower < upper:
        nums[lower], nums[upper] = nums[upper], nums[lower]
        lower += 1
        upper -= 1


12InversionsOfArrayGood.ipynb
Given an array of N integers, count the inversion of the array

What is an inversion of an array? Definition: for all i & j < size of array, if i < j then you have to find
pair (A[i],A[j]) such that A[j] < A[i].
def inversions(arr):
    count = 0
    for i in range(len(arr)):
        for j in range(i+1,len(arr)):
            if arr[i] > arr[j]:
                count += 1
    return count

13SquareSortedGood.ipynb
def squareSorted(arr):
    return sorted([x*x for x in arr])
print(squareSorted([-1,-2,0,1]))
#https://leetcode.com/problems/squares-of-a-sorted-array/
def sortedSquares(nums: List[int]) -> List[int]:
    i = 0
    while i < len(nums):
        if nums[i] >= 0:
            break
        i += 1
    posP, negP = i, i - 1
    if posP == 0:
        res = [x*x for x in nums]
        return res
    elif posP == len(nums):
        res = [x*x for x in nums]
        return res[::-1]
    res = [None]* len(nums)
    i = 0
    while negP > -1 and posP < len(nums) and i < len(nums):
        negVal, posVal = nums[negP]**2, nums[posP]**2
        if negVal > posVal:
            res[i] = posVal
            posP += 1
        else:
            res[i] = negVal
            negP -= 1
        i += 1
    if negP == -1:
        while i < len(nums):
            res[i] = nums[posP]**2
            i += 1
            posP += 1
    elif posP == len(nums):
        while i < len(nums):
            res[i] = nums[negP]**2
            i += 1
            negP -= 1
    return res



15CreateFrequencyArrayIfTheElementsCanBeVeryLargeGood.ipynb

def findOccurences(self, A):
# Dictionary to store the occurrences of each number
    count_dict = {}

    # Count occurrences of each number
    for num in A:
        count_dict[num] = count_dict.get(num, 0) + 1

    # Create a list of tuples (number, occurrence count)
    occurrences = [(num, count_dict[num]) for num in count_dict]

    # Sort the list based on the occurrence count
    occurrences.sort(key=lambda x: (x[0], x[1]))

    # Extract only the occurrence counts and return
    return [occ[1] for occ in occurrences]

16SequentialDigitsGood.ipynb
def SequentialDigitsGood(low,high):
    string = "123456789"
    lowC, highC = low, high
    lowDig, highDig = 0, 0
    while lowC > 0: # calculate the number of dogits in low
        lowC = lowC // 10
        lowDig += 1
    while highC > 0: # calculate the number of digits in high
        highC = highC // 10
        highDig += 1
    print(highDig, lowDig)
    digits = [x for x in range(lowDig,highDig+1,1)] # calculate the number of digits in range
    print(digits)
    res = []
    p1, p2 = 0, 0
    for i in digits:
        p1, p2  = 0, p1 + i  # Yahan par p2 = p1 +i pehle evaluate hota hai
        print(p1,i,p2)
        while p2 <= len(string):
            resStr = string[p1:p2]
            print(resStr, p1, p2)
            if low <= int(resStr) and int(resStr) <= high:
                res.append(int(resStr))
            elif high < int(resStr):
                break
            p1 += 1
            p2 += 1
        p1, p2 = 0, 0 # iski jarurat isley hai warna p2 = p1 + i me p1 ki purani value reh jaaegi
    return res


